# docker-compose.yml (2025년 기준)
version: '3.9'

# 데이터를 받으면
# ocr처리후
# redis 에 임시저장
# 사용자가 웹앱에서 확인후
# 최종적으로 mysql 에 저장하는 구조

# docker-compose run --rm ocr-processor 명령어로 컨테이너 껏다켰다해서 리소스 적게 쓰기
# web-app 은 24시간 켜두기
# redis, mysql 도 24시간 켜두기
# 데이터 읽은걸 변환하는건 제미나이-flash api 사용
# docker-compose up을 실행하면, docker-compose.yml 파일이 있는 위치에 redis_data와 mysql_data 폴더가 자동으로 생성
# docker-compose.yml (2025년 기준 최종 추천 버전)

services:
  # ... (frontend 서비스) ...

  backend:
    build:
      context: ./backend
    container_name: backend_api
    env_file:
      - .env
    volumes:
      # backend는 파일을 업로드 받아 이 폴더에 넣는 역할만 함
      - ./receipts_to_process:/app/receipts_to_process
    depends_on:
      - redis
      - db

  ocr-processor:
    build:
      context: ./ocr_processor
    container_name: ocr_processor
    env_file:
      - .env
    volumes:
      # ocr-processor는 두 개의 폴더를 사용함
      # 1. 이 폴더에서 파일을 읽어오고,
      - ./receipts_to_process:/app/receipts_to_process
      # 2. 처리가 끝나면 이 폴더로 파일을 옮김
      - ./receipts_processed:/app/receipts_processed
    depends_on:
      - redis

  # ... (redis, db 서비스) ...


  # # 2. 회계 담당자가 사용할 웹 애플리케이션 (폐기)
  # web-app:
  #   build:
  #     context: ./web_app
  #   container_name: web_app
  #   ports:
  #     - "5001:5000" # 외부(사용자 브라우저)에서 접속해야 하므로 포트 개방
  #   env_file:
  #     - .env
  #   depends_on:
  #     - redis
  #     - db

# 2. 프론트엔드 (Nginx): 사용자에게 UI를 보여주고 API 요청을 백엔드로 전달
  frontend:
    build:
      context: ./frontend # ./frontend 폴더에 Dockerfile과 nginx.conf, UI 파일들 위치
    container_name: frontend_web
    ports:
      - "5001:80" # 사용자는 5001 포트로 접속
    depends_on:
      - backend

  # 3. 백엔드 (Python API 서버)
  backend:
    build:
      context: ./backend # 기존 web_app을 backend 폴더로 변경
    container_name: backend_api
    # ports: # 외부로 직접 노출할 필요 없음. Nginx가 대신 연결해줌
    env_file:
      - .env
    depends_on:
      - redis
      - db  
    volumes:
      - ./receipts_to_process:/app/receipts_to_process # 영수증 폴더 마운트

  # 3. 1차 임시 저장소 (Redis)
  redis:
    image: redis:7.2-alpine
    container_name: redis_db
    # ports: # 주석 처리. web-app이 Docker 내부 네트워크로 redis에 직접 접속
    #   - "6379:6379"
    volumes:
      - redis_data:/data # MySQL과 동일하게 Docker Volume 사용으로 통일

  # 4. 최종 데이터 저장소 (MySQL)
  db:
    image: mysql:8.4
    container_name: mysql_db
    environment:
      MYSQL_ROOT_PASSWORD: ${MYSQL_ROOT_PASSWORD}
      MYSQL_DATABASE: ${MYSQL_DATABASE}
      MYSQL_USER: ${MYSQL_USER}
      MYSQL_PASSWORD: ${MYSQL_PASSWORD}
    # ports: # 주석 처리. web-app이 Docker 내부 네트워크로 db에 직접 접속
    #   - "3306:3306"
    volumes:
      - mysql_data:/var/lib/mysql
      - ./db_init:/docker-entrypoint-initdb.d # 초기화 스크립트 마운트

# Docker가 관리하는 데이터 영속성 영역 정의 (일관성 유지)
volumes:
  redis_data:
  mysql_data: